package org.nervos.ckb.sign.signer;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import org.nervos.ckb.crypto.Keccak256;
import org.nervos.ckb.crypto.secp256k1.ECKeyPair;
import org.nervos.ckb.crypto.secp256k1.Sign;
import org.nervos.ckb.sign.Context;
import org.nervos.ckb.sign.ScriptGroup;
import org.nervos.ckb.sign.ScriptSigner;
import org.nervos.ckb.type.Script;
import org.nervos.ckb.type.fixed.UInt64;
import org.nervos.ckb.type.transaction.Transaction;
import org.nervos.ckb.utils.Numeric;

public class PwSigner implements ScriptSigner {
  private static final int WITNESS_OFFSET_IN_BYTE = 20;
  private static final int SIGNATURE_LENGTH_IN_BYTE = 65;

  private static PwSigner INSTANCE;

  private PwSigner() {}

  public static PwSigner getInstance() {
    if (INSTANCE == null) {
      INSTANCE = new PwSigner();
    }
    return INSTANCE;
  }

  @Override
  public boolean signTransaction(
      Transaction transaction, ScriptGroup scriptGroup, Context context) {
    Script script = scriptGroup.getScript();
    String privateKey = context.getPrivateKey();
    if (isMatched(privateKey, script.args)) {
      return signScriptGroup(transaction, scriptGroup, privateKey);
    } else {
      return false;
    }
  }

  private boolean signScriptGroup(
      Transaction transaction, ScriptGroup scriptGroup, String privateKey) {
    Keccak256 keccak256 = new Keccak256();
    String txHash = transaction.computeHash();
    keccak256.update(Numeric.hexStringToByteArray(txHash));

    List<String> witnesses = transaction.witnesses;
    for (int i : scriptGroup.getInputIndices()) {
      byte[] witness = Numeric.hexStringToByteArray(witnesses.get(i));
      keccak256.update(new UInt64(witness.length).toBytes());
      keccak256.update(witness);
    }

    byte[] digest = keccak256.doFinalBytes();

    ECKeyPair ecKeyPair = ECKeyPair.createWithPrivateKey(privateKey, false);
    byte[] signature = ethereumPersonalSign(digest, ecKeyPair);

    int index = scriptGroup.getInputIndices().get(0);
    // TODO: need parsing from witnessArgs but not replace in place
    String witness = Numeric.cleanHexPrefix(witnesses.get(index));
    witness =
        "0x"
            + witness.substring(0, WITNESS_OFFSET_IN_BYTE * 2)
            + Numeric.toHexStringNoPrefix(signature)
            + witness.substring(WITNESS_OFFSET_IN_BYTE * 2 + SIGNATURE_LENGTH_IN_BYTE * 2);

    witnesses.set(index, witness);
    return true;
  }

  private static byte[] ethereumPersonalSign(byte[] message, ECKeyPair ecKeyPair) {
    byte[] prefix =
        ("\u0019Ethereum Signed Message:\n" + message.length).getBytes(StandardCharsets.UTF_8);
    byte[] encodedMessage = new byte[prefix.length + message.length];
    System.arraycopy(prefix, 0, encodedMessage, 0, prefix.length);
    System.arraycopy(message, 0, encodedMessage, prefix.length, message.length);

    Keccak256 keccak256 = new Keccak256();
    keccak256.update(encodedMessage);
    byte[] digest = keccak256.doFinalBytes();

    return Sign.signMessage(digest, ecKeyPair).getSignature();
  }

  // Check if the script with `scriptArgs` is generated by and can be unlocked by `privateKey`
  public boolean isMatched(String privateKey, String scriptArgs) {
    if (scriptArgs == null || privateKey == null) {
      return false;
    }

    Keccak256 keccak256 = new Keccak256();
    ECKeyPair ecKeyPair = ECKeyPair.createWithPrivateKey(privateKey, false);
    keccak256.update(ecKeyPair.getPublicKeyBytes());
    byte[] publicKeyHash = keccak256.doFinalBytes();

    byte[] ethereumAddress =
        Arrays.copyOfRange(publicKeyHash, publicKeyHash.length - 20, publicKeyHash.length);

    byte[] scriptArgsBytes = Numeric.hexStringToByteArray(scriptArgs);
    return Arrays.equals(scriptArgsBytes, ethereumAddress);
  }
}

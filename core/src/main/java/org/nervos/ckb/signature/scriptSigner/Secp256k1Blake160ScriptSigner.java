package org.nervos.ckb.signature.scriptSigner;

import java.util.List;
import org.nervos.ckb.crypto.Blake2b;
import org.nervos.ckb.crypto.Hash;
import org.nervos.ckb.crypto.secp256k1.ECKeyPair;
import org.nervos.ckb.crypto.secp256k1.Sign;
import org.nervos.ckb.signature.Context;
import org.nervos.ckb.signature.ScriptGroup;
import org.nervos.ckb.signature.ScriptSigner;
import org.nervos.ckb.type.Script;
import org.nervos.ckb.type.fixed.UInt64;
import org.nervos.ckb.type.transaction.Transaction;
import org.nervos.ckb.utils.Numeric;

public class Secp256k1Blake160ScriptSigner implements ScriptSigner {
  private static final int WITNESS_OFFSET_IN_BYTE = 20;
  private static final int SIGNATURE_LENGTH_IN_BYTE = 65;

  @Override
  public boolean signTx(Transaction transaction, ScriptGroup scriptGroup, Context context) {
    if (scriptGroup == null
        || scriptGroup.getInputIndices() == null
        || scriptGroup.getInputIndices().isEmpty()) {
      return false;
    }

    Script script = scriptGroup.getScript();
    String privateKey = context.getPrivateKey();
    if (isMatched(privateKey, script.args) == false) {
      return false;
    }

    int index = scriptGroup.getInputIndices().get(0);
    ECKeyPair ecKeyPair = ECKeyPair.createWithPrivateKey(privateKey, false);

    String txHash = transaction.computeHash();
    List<String> witnesses = transaction.witnesses;
    Blake2b blake2b = new Blake2b();
    blake2b.update(Numeric.hexStringToByteArray(txHash));

    for (int i : scriptGroup.getInputIndices()) {
      byte[] witness = Numeric.hexStringToByteArray(witnesses.get(i));
      blake2b.update(new UInt64(witness.length).toBytes());
      blake2b.update(witness);
    }
    for (int i = transaction.inputs.size(); i < transaction.witnesses.size(); i++) {
      byte[] witness = Numeric.hexStringToByteArray(witnesses.get(i));
      blake2b.update(new UInt64(witness.length).toBytes());
      blake2b.update(witness);
    }

    byte[] message = blake2b.doFinalBytes();
    byte[] signature = Sign.signMessage(message, ecKeyPair).getSignature();

    String witness = witnesses.get(index);
    witness =
        "0x"
            + witness.substring(0, WITNESS_OFFSET_IN_BYTE * 2)
            + Numeric.toHexStringNoPrefix(signature)
            + witness.substring(WITNESS_OFFSET_IN_BYTE * 2 + SIGNATURE_LENGTH_IN_BYTE * 2);

    witnesses.set(index, witness);
    return true;
  }

  // Check if the script with `scriptArgs` is generated by and can be unlocked by `privateKey`
  private boolean isMatched(String privateKey, String scriptArgs) {
    if (scriptArgs == null || privateKey == null) {
      return false;
    }
    ECKeyPair ecKeyPair = ECKeyPair.createWithPrivateKey(privateKey, true);
    String publicKeyHash =
        Numeric.toHexString(Hash.blake160(ecKeyPair.getPublicKey().toByteArray()));
    return scriptArgs.equals(publicKeyHash);
  }
}
